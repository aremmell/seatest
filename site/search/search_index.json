{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"seatest","text":"<p>This is a test MkDocs material site. Let's see if it's something great!</p>"},{"location":"evaluators/","title":"Evaluators","text":"<p>seatest evaluators make writing tests less painful. They provide a straightforward yet comprehensive way to express what the results of your tests should be, in a granular fashion.</p> <p>Each evaluator ultimately boils down to a truthy statement about the expression and data passed into it. At each step of your test, its state can be positively confirmed to either be correct or incorrect.</p> <p>Any evaluator that results in a false expression will cause the active test to fail[^1] (but not stop\u2014it is on the TODO list to make that behavior configurable). Finally, additional helpers are provided to check the state of a test at any time, and optionally exit immediately.</p> <p>[^1]: All evaluators but <code>ST_EXPECT</code>.</p>"},{"location":"evaluators/#general-purpose","title":"General Purpose","text":"Evaluator Expression ST_EXPECT any truthy expression; if false, a warning is set for the active test (no failure) ST_TRUE any truthy expression ST_FALSE !(any truthy expression) ST_EQUAL lhs == rhs ST_NOT_EQUAL lhs != rhs ST_LESS_THAN lhs &lt; rhs ST_LESS_THAN_OR_EQUAL lhs &lt;= rhs ST_GREATER_THAN lhs &gt; rhs ST_GREATER_THAN_OR_EQUAL lhs &gt;= rhs ST_NULL ptr == NULL ST_NOT_NULL ptr != NULL"},{"location":"evaluators/#bitwise","title":"Bitwise","text":"Evaluator Expression ST_BITS_HIGH (bitmask &amp; bits) == bits ST_BITS_LOW (bitmask &amp; bits) == 0, ST_BITWISE_EQUAL memcmp(&amp;lhs, &amp;rhs, size) == 0 ST_BITWISE_NOT_EQUAL memcmp(&amp;lhs, &amp;rhs, size) != 0 ST_BITWISE_ZEROED all bytes == 0 ST_BITWISE_NOT_ZEROED any byte != 0"},{"location":"evaluators/#string","title":"String","text":"Evaluator Expression ST_STR_EMPTY str == NULL || *(str) == '\\0' ST_STR_NOT_EMPTY str != NULL &amp;&amp; *str != '\\0' ST_STR_EQUAL strcmp(str1, str2) == 0 ST_STR_NOT_EQUAL strcmp(str1, str2) != 0 ST_STR_EQUAL_I strcasecmp/StrCmpI(str1, str2) == 0 ST_STR_NOT_EQUAL_I strcasecmp/StrCmpI(str1, str2) != 0 ST_STR_CONTAINS strstr/StrStr(needle, haystack) != NULL ST_STR_NOT_CONTAINS strstr/StrStr(needle, haystack) == NULL ST_STR_CONTAINS_I strcasestr/StrStrI(needle, haystack) != NULL ST_STR_NOT_CONTAINS_I strcasestr/StrStrI(needle, haystack) == NULL ST_STR_BEGINSWITH strncmp/StrCmpN(needle, haystack, needle_len) == 0 ST_STR_NOT_BEGINSWITH strncmp/StrCmpN(needle, haystack, needle_len) != 0 ST_STR_BEGINSWITH_I strncasecmp/StrCmpNI(needle, haystack, needle_len) == 0 ST_STR_NOT_BEGINSWITH_I strncasecmp/StrCmpNI(needle, haystack, needle_len) != 0 ST_STR_BEGINSWITH_WSPACE isspace(str[0]) ST_STR_NOT_BEGINSWITH_WSPACE !isspace(str[0]) ST_STR_ENDSWITH strncmp/StrCmpN(haystack + (haystack_len - needle_len), needle_len) == 0 ST_STR_NOT_ENDSWITH strncmp/StrCmpN(haystack + (haystack_len - needle_len), needle_len) != 0 ST_STR_ENDSWITH_I strncasecmp/StrCmpNI(haystack + (haystack_len - needle_len), needle_len) == 0 ST_STR_NOT_ENDSWITH_I strncasecmp/StrCmpNI(haystack + (haystack_len - needle_len), needle_len) != 0 ST_STR_ENDSWITH_WSPACE isspace(p[strlen(p) - 1]) ST_STR_NOT_ENDSWITH_WSPACE !isspace(p[strlen(p) - 1]) ST_STR_ALPHA foreach(str) =&gt; isalpha ST_STR_NUMERIC foreach(str) =&gt; isdigit ST_STR_ALPHANUMERIC foreach(str) =&gt; isalnum"},{"location":"evaluators/#numeric","title":"Numeric","text":"Evaluator Expression ST_NUM_POSITIVE num &gt; 0 ST_NUM_NEGATIVE num &lt; 0 ST_NUM_EVEN num % 2 == 0 ST_NUM_ODD num % 2 != 0 ST_NUM_MULTIPLE_OF num % exp == 0 ST_NUM_NOT_MULTIPLE_OF num % exp != 0 ST_NUM_IN_RANGE num &gt;= low &amp;&amp; num &lt;= high ST_NUM_NOT_IN_RANGE num &lt; low || num &gt; high"},{"location":"evaluators/#array","title":"Array","text":"Evaluator Expression ST_ARRAY_EQUAL sizeof(arr1[0]) == sizeof(arr2[0]) &amp;&amp; count1 == count2 &amp;&amp; all elems == ST_ARRAY_NOT_EQUAL sizeof(arr1[0]) != sizeof(arr2[0]) ST_ARRAY_CONTAINS sizeof(arr[0]) == sizeof(val) &amp;&amp; any elem == val ST_ARRAY_NOT_CONTAINS sizeof(arr[0]) != sizeof(val) &amp;&amp; all elems != val ST_ARRAY_UNIQUE foreach(arr) =&gt; (n) foreach(arr) =&gt; (j) arr[n] != arr[j]"}]}